# **Unentropy**

```
▄▄ ▄▄ ▄▄  ▄▄ ▄▄▄▄▄ ▄▄  ▄▄ ▄▄▄▄ ▄▄▄▄   ▄▄▄  ▄▄▄▄  ▄▄ ▄▄
██ ██ ███▄██ ██▄▄  ███▄██  ██  ██▄█▄ ██▀██ ██▄█▀ ▀███▀
▀███▀ ██ ▀██ ██▄▄▄ ██ ▀██  ██  ██ ██ ▀███▀ ██      █
```

**Unentropy: Codebase Metrics Tracking, Decoupled.**

## **What is Unentropy?**

**Unentropy** is an open-source tool designed to help engineering teams maintain and improve long-living codebases by relentlessly tracking **code metrics** right where the changes happen: in the Continuous Integration (CI) pipeline.

Unlike monolithic tools that require dedicated servers, cloud hosting, or complex infrastructure, **Unentropy is fully self-contained within your existing GitHub Actions workflow.** It provides a lightweight, serverless solution for historical data tracking and reporting. With Unentropy, you own your metrics and you are in full control.

## **The Problem Unentropy Solves**

As codebases mature, teams need to track, internal metrics specific to their business logic or technological evolution. This could range from simple counts to highly specific indicators generated by custom scripts.

1. **Tracking Custom Metrics:** Standard tools often don't support the highly custom, often _ad-hoc_, metrics critical for a specific project (e.g., "Ratio of Modern Framework usage to Legacy Code").
2. **Server Overhead:** Hosting and maintaining a dedicated service (like SonarQube or custom dashboards) just to track trends is significant overhead, especially for smaller or distributed teams.
3. **Data Persistence:** You need a simple, reliable way to persist historical metrics associated with specific commits, without adding another managed service.

## **Key Features**

- **Serverless Architecture:** No server, no cloud, no recurring fees. Everything lives in your repository's workflow artifacts.
- **Easy Metric Collection:** Unentropy ships with easy to use collectors that report standard code metrics - lines of code, test coverage, complexity, and more.
- **Custom Metrics:** You can track ANY code metric that is important for your specific use-case: modern to legacy code ratio, refactoring progress, and so on.
- **Quality Gates** Metrics can be reported in Pull Requests. You can configure thresholds and prevent merging the code that doesn't match your standard (e.g. only if code coverage is above XX%).
- **Git-Native Tracking:** Metrics are always tied directly to the commit SHA that generated them. The configuration is living in your repository and is versioned as well.
- **Simple Reporting:** Generate static trend charts (e.g., trend lines for LOC, complexity score, etc.) accessible directly from the CI run summary.

## **Getting Started**

### Basic Three-Action Workflow

Add the three Unentropy actions to your existing CI workflow:

```yaml
- name: Find latest database
  id: find-database
  uses: ./.github/actions/find-database
  with:
    database-artifact: "unentropy-metrics"
    database-path: "./unentropy-metrics.db"

- name: Collect metrics
  id: collect-metrics
  uses: ./.github/actions/collect-metrics
  with:
    config-path: "./unentropy.json"
    database-path: "./unentropy-metrics.db"

- name: Generate report
  id: generate-report
  uses: ./.github/actions/generate-report
  with:
    database-path: "./unentropy-metrics.db"
    output-path: "./unentropy-report.html"
```

### Configuration

Create an `unentropy.json` file to define your metrics:

```json
{
  "metrics": [
    {
      "name": "test_coverage",
      "command": "bun test --coverage",
      "parser": "regex",
      "pattern": "Coverage: (\\d+\\.\\d+)%",
      "unit": "%"
    },
    {
      "name": "lines_of_code",
      "command": "find src/ -name '*.ts' | wc -l",
      "parser": "raw",
      "unit": "LOC"
    }
  ]
}
```

### Review Reports

After the CI run, download the `unentropy-report.html` artifact to see the latest trends and track your progress against codebase entropy!

### Benefits for This Project

- **Track test coverage trends** - Ensure we maintain or improve code quality
- **Monitor code growth** - Keep an eye on project scope and complexity
- **Demonstrate capabilities** - Show real-world usage of Unentropy
- **Validate the tool** - Dogfooding helps us identify and fix issues quickly

## **Development Setup**

### Prerequisites

- [Bun](https://bun.sh/) v1.2 or later

### Setup

```bash
# Clone the repository
git clone <repository-url>
cd unentropy

# Install dependencies
bun install

# Verify setup
bun run typecheck
bun test
bun run build
```

### Available Commands

- `bun run build` - Compile TypeScript to JavaScript
- `bun test` - Run test suite
- `bun test --watch` - Run tests in watch mode
- `bun run typecheck` - Type check without emitting files
- `bun run lint` - Check code quality with ESLint
- `bun run lint:fix` - Auto-fix linting issues
- `bun run format` - Format code with Prettier
- `bun run format:check` - Check code formatting

### Project Structure

```
unentropy/
├── src/
│   ├── index.ts          # Package entry point
│   └── lib/              # Library modules
├── tests/
│   ├── unit/             # Unit tests
│   ├── integration/      # Integration tests
│   └── contract/         # Contract tests
├── dist/                 # Build output (generated)
└── .github/workflows/    # CI/CD configuration
```

### Performance Targets

- Type checking: <5s
- Test suite: <2s
- 100% code passes linting

## **Contribution**

Unentropy is an open-source project designed _by_ engineers for engineers. We welcome feedback, ideas, and contributions\! Please see our \[CONTRIBUTING.md\] file for guidelines.

**License:** MIT
