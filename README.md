# **Unentropy**

**Unentropy: CI/CD Codebase Health Tracking, Decoupled.**

_(The tendency of a complex codebase to increase in disorder is known as "code entropy." Unentropy aims to reverse that trend.)_

## **üí° What is Unentropy?**

**Unentropy** is an open-source tool designed to help engineering teams maintain and improve mid-sized to large, long-living codebases by relentlessly tracking **custom code metrics** right where the changes happen: in the Continuous Integration (CI) pipeline.

Unlike monolithic tools that require dedicated servers, cloud hosting, or complex infrastructure, **Unentropy is fully self-contained within your existing GitHub Actions workflow.** It provides a lightweight, serverless solution for historical data tracking and reporting.

## **üéØ The Problem Unentropy Solves**

As codebases mature, teams need to track custom, internal metrics specific to their business logic or technological evolution. This could range from simple counts to highly specific indicators generated by custom scripts.

1. **Tracking Custom Metrics:** Standard tools often don't support the highly custom, often _ad-hoc_, metrics critical for a specific project (e.g., "Ratio of Modern Framework usage to Legacy Code").
2. **Server Overhead:** Hosting and maintaining a dedicated service (like SonarQube or custom dashboards) just to track trends is significant overhead, especially for smaller or distributed teams.
3. **Data Persistence:** You need a simple, reliable way to persist historical metrics associated with specific commits, without adding another managed service.

## **üõ†Ô∏è How Unentropy Works**

Unentropy operates entirely within a GitHub workflow by following a simple three-step cycle:

1. **Fetch:** The Unentropy GitHub Action **downloads** the existing, historical metrics database from the latest successful run (saved as a GitHub Artifact).
2. **Collect & Update:** It executes your custom metric collection scripts, gathers the new data points (along with the current Git SHA and timestamp), and securely adds the new row to the database file.
3. **Report & Persist:** It generates a simple, **static HTML trend report** (with charts) and then **uploads both the updated database file and the report file** back as GitHub Artifacts, making them immediately available for download and review.

This allows teams to see trends, spot entropy spikes, and visualize codebase health over time, all without maintaining a single external server.

## **‚ú® Key Features (MVP Goals)**

- **Serverless Architecture:** No server, no cloud, no recurring fees. Everything lives in your repository's workflow artifacts.
- **Custom Metric Agnostic:** Easily consume key-value metrics generated by _any_ script or custom tool you write.
- **Git-Native Tracking:** Metrics are always tied directly to the commit SHA that generated them.
- **Simple Reporting:** Generate static trend charts (e.g., trend lines for LOC, complexity score, etc.) accessible directly from the CI run summary.

## **üèóÔ∏è Tech Stack**

_(These are the selected technologies for the initial implementation, chosen for simplicity and GitHub Action compatibility. We welcome community input on these choices\!)_

| Component              | Chosen Technology                        | Why?                                                                                                                           |
| :--------------------- | :--------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------- |
| **Tooling Language**   | **Node.js / TypeScript**                 | Native support for GitHub Actions, high performance, and robust tooling ecosystem.                                             |
| **Data Storage**       | **SQLite**                               | The gold standard for lightweight, file-based, zero-config databases. Perfect for storing historical data in an artifact file. |
| **Data Visualization** | **Chart.js**                             | Used to generate simple, static charts embedded in an HTML file for easy artifact viewing.                                     |
| **Packaging**          | **GitHub Action (JavaScript/Container)** | The core delivery mechanism, providing a single, clean step for users' workflows.                                              |

## **üöÄ Getting Started (Planned Usage)**

1. **Add the Action:** Include the unentropy/action@v1 step in your existing CI workflow.
2. **Configure Metrics:** Create an unentropy.yml file to define which scripts to run to generate your metrics (e.g., loc_script: ./scripts/count_loc.sh).
3. **Review Reports:** After the CI run, download the generated unentropy-report.html artifact to see the latest trends and track your progress against codebase entropy\!

## **üîç Self-Monitoring Example**

Unentropy practices what it preaches - this repository uses Unentropy to track its own code health metrics! This serves as both a genuine project monitoring tool and a living example for potential users.

### Current Self-Monitoring Metrics

The `unentropy.json` file in this repository tracks:

1. **Test Coverage** (`test_coverage`)
   - **What**: Percentage of code covered by tests
   - **How**: `bun test --coverage` with parsing to extract percentage
   - **Unit**: `%`

2. **Lines of Code** (`lines_of_code`)
   - **What**: Total TypeScript lines in `src/` directory
   - **How**: `find src/ -name '*.ts' | wc -l`
   - **Unit**: `LOC`

### How It Works in This Repository

Every push and pull request to this repository automatically:

1. **Collects** the two metrics above using the defined commands
2. **Stores** the data in a SQLite database persisted as a GitHub Artifact
3. **Generates** an HTML report showing trends over time
4. **Uploads** both the updated database and report as artifacts

You can see the latest reports by:

- Checking the "Artifacts" section of any GitHub Actions run
- Downloading the `metrics-report` artifact
- Opening the `unentropy-report.html` file in your browser

### Benefits for This Project

- **Track test coverage trends** - Ensure we maintain or improve code quality
- **Monitor code growth** - Keep an eye on project scope and complexity
- **Demonstrate capabilities** - Show real-world usage of Unentropy
- **Validate the tool** - Dogfooding helps us identify and fix issues quickly

## **üßë‚Äçüíª Development Setup**

### Prerequisites

- [Bun](https://bun.sh/) v1.2 or later

### Setup

```bash
# Clone the repository
git clone <repository-url>
cd unentropy

# Install dependencies
bun install

# Verify setup
bun run typecheck
bun test
bun run build
```

### Available Commands

- `bun run build` - Compile TypeScript to JavaScript
- `bun test` - Run test suite
- `bun test --watch` - Run tests in watch mode
- `bun run typecheck` - Type check without emitting files
- `bun run lint` - Check code quality with ESLint
- `bun run lint:fix` - Auto-fix linting issues
- `bun run format` - Format code with Prettier
- `bun run format:check` - Check code formatting

### Project Structure

```
unentropy/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts          # Package entry point
‚îÇ   ‚îî‚îÄ‚îÄ lib/              # Library modules
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ unit/             # Unit tests
‚îÇ   ‚îú‚îÄ‚îÄ integration/      # Integration tests
‚îÇ   ‚îî‚îÄ‚îÄ contract/         # Contract tests
‚îú‚îÄ‚îÄ dist/                 # Build output (generated)
‚îî‚îÄ‚îÄ .github/workflows/    # CI/CD configuration
```

### Performance Targets

- Type checking: <5s
- Test suite: <2s
- 100% code passes linting

## **ü§ù Contribution**

Unentropy is an open-source project designed _by_ engineers for engineers. We welcome feedback, ideas, and contributions\! Please see our \[CONTRIBUTING.md\] file for guidelines.

**License:** MIT
